// Generated by @sohcah/openapi-generator
// Version: 0.1.1
/*prettier-ignore*/
/*eslint-disable*/
import * as Schema from "effect/Schema";
import { Effect } from "effect";
import { type SkipToken, mutationOptions, queryOptions, type QueryKey, skipToken } from "@tanstack/react-query";
export class Api {
  #fetch;
  constructor(fetch: (path: string, options: {
    method: string;
    headers?: Headers;
    body?: string | Blob | FormData | URLSearchParams;
  }) => Promise<Response>) {
    this.#fetch = fetch;
  }
  /**
  ### Add a new pet to the store.
  Add a new pet to the store.
  **/
  async addPet(parameters: Schema.Schema.Type<typeof AddPet_Parameters>) {
    const params = await Schema.encodePromise(AddPet_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(AddPet_Response)(response);
  }
  /**
  ### Add a new pet to the store.
  Add a new pet to the store.
  **/
  addPetMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof AddPet_Parameters>) => this.addPet(parameters)
    });
  }
  /**
  ### Update an existing pet
  Update an existing pet by Id.
  **/
  async updatePet(parameters: Schema.Schema.Type<typeof UpdatePet_Parameters>) {
    const params = await Schema.encodePromise(UpdatePet_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "put",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(UpdatePet_Response)(response);
  }
  /**
  ### Update an existing pet
  Update an existing pet by Id.
  **/
  updatePetMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof UpdatePet_Parameters>) => this.updatePet(parameters)
    });
  }
  /**
  ### Finds Pets by status.
  Multiple status values can be provided with comma separated strings.
  **/
  async findPetsByStatus(parameters: Schema.Schema.Type<typeof FindPetsByStatus_Parameters>) {
    const params = await Schema.encodePromise(FindPetsByStatus_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(FindPetsByStatus_Response)(response);
  }
  /**
  ### Finds Pets by status.
  Multiple status values can be provided with comma separated strings.
  **/
  findPetsByStatusQuery(parameters: Schema.Schema.Type<typeof FindPetsByStatus_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["FindPetsByStatus", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.findPetsByStatus(parameters)
    });
  }
  /**
  ### Finds Pets by tags.
  Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
  **/
  async findPetsByTags(parameters: Schema.Schema.Type<typeof FindPetsByTags_Parameters>) {
    const params = await Schema.encodePromise(FindPetsByTags_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(FindPetsByTags_Response)(response);
  }
  /**
  ### Finds Pets by tags.
  Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
  **/
  findPetsByTagsQuery(parameters: Schema.Schema.Type<typeof FindPetsByTags_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["FindPetsByTags", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.findPetsByTags(parameters)
    });
  }
  /**
  ### Find pet by ID.
  Returns a single pet.
  **/
  async getPetById(parameters: Schema.Schema.Type<typeof GetPetById_Parameters>) {
    const params = await Schema.encodePromise(GetPetById_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(GetPetById_Response)(response);
  }
  /**
  ### Find pet by ID.
  Returns a single pet.
  **/
  getPetByIdQuery(parameters: Schema.Schema.Type<typeof GetPetById_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["GetPetById", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.getPetById(parameters)
    });
  }
  /**
  ### Updates a pet in the store with form data.
  Updates a pet resource based on the form data.
  **/
  async updatePetWithForm(parameters: Schema.Schema.Type<typeof UpdatePetWithForm_Parameters>) {
    const params = await Schema.encodePromise(UpdatePetWithForm_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(UpdatePetWithForm_Response)(response);
  }
  /**
  ### Updates a pet in the store with form data.
  Updates a pet resource based on the form data.
  **/
  updatePetWithFormMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof UpdatePetWithForm_Parameters>) => this.updatePetWithForm(parameters)
    });
  }
  /**
  ### Deletes a pet.
  Delete a pet.
  **/
  async deletePet(parameters: Schema.Schema.Type<typeof DeletePet_Parameters>) {
    const params = await Schema.encodePromise(DeletePet_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "delete",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(DeletePet_Response)(response);
  }
  /**
  ### Deletes a pet.
  Delete a pet.
  **/
  deletePetMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof DeletePet_Parameters>) => this.deletePet(parameters)
    });
  }
  /**
  ### Uploads an image.
  Upload image of the pet.
  **/
  async uploadFile(parameters: Schema.Schema.Type<typeof UploadFile_Parameters>) {
    const params = await Schema.encodePromise(UploadFile_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(UploadFile_Response)(response);
  }
  /**
  ### Uploads an image.
  Upload image of the pet.
  **/
  uploadFileMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof UploadFile_Parameters>) => this.uploadFile(parameters)
    });
  }
  /**
  ### Returns pet inventories by status.
  Returns a map of status codes to quantities.
  **/
  async getInventory(parameters: Schema.Schema.Type<typeof GetInventory_Parameters>) {
    const params = await Schema.encodePromise(GetInventory_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(GetInventory_Response)(response);
  }
  /**
  ### Returns pet inventories by status.
  Returns a map of status codes to quantities.
  **/
  getInventoryQuery(parameters: Schema.Schema.Type<typeof GetInventory_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["GetInventory", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.getInventory(parameters)
    });
  }
  /**
  ### Place an order for a pet.
  Place a new order in the store.
  **/
  async placeOrder(parameters: Schema.Schema.Type<typeof PlaceOrder_Parameters>) {
    const params = await Schema.encodePromise(PlaceOrder_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(PlaceOrder_Response)(response);
  }
  /**
  ### Place an order for a pet.
  Place a new order in the store.
  **/
  placeOrderMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof PlaceOrder_Parameters>) => this.placeOrder(parameters)
    });
  }
  /**
  ### Find purchase order by ID.
  For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
  **/
  async getOrderById(parameters: Schema.Schema.Type<typeof GetOrderById_Parameters>) {
    const params = await Schema.encodePromise(GetOrderById_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(GetOrderById_Response)(response);
  }
  /**
  ### Find purchase order by ID.
  For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
  **/
  getOrderByIdQuery(parameters: Schema.Schema.Type<typeof GetOrderById_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["GetOrderById", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.getOrderById(parameters)
    });
  }
  /**
  ### Delete purchase order by identifier.
  For valid response try integer IDs with value < 1000. Anything above 1000 or non-integers will generate API errors.
  **/
  async deleteOrder(parameters: Schema.Schema.Type<typeof DeleteOrder_Parameters>) {
    const params = await Schema.encodePromise(DeleteOrder_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "delete",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(DeleteOrder_Response)(response);
  }
  /**
  ### Delete purchase order by identifier.
  For valid response try integer IDs with value < 1000. Anything above 1000 or non-integers will generate API errors.
  **/
  deleteOrderMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof DeleteOrder_Parameters>) => this.deleteOrder(parameters)
    });
  }
  /**
  ### Create user.
  This can only be done by the logged in user.
  **/
  async createUser(parameters: Schema.Schema.Type<typeof CreateUser_Parameters>) {
    const params = await Schema.encodePromise(CreateUser_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(CreateUser_Response)(response);
  }
  /**
  ### Create user.
  This can only be done by the logged in user.
  **/
  createUserMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof CreateUser_Parameters>) => this.createUser(parameters)
    });
  }
  /**
  ### Creates list of users with given input array.
  Creates list of users with given input array.
  **/
  async createUsersWithListInput(parameters: Schema.Schema.Type<typeof CreateUsersWithListInput_Parameters>) {
    const params = await Schema.encodePromise(CreateUsersWithListInput_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "post",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(CreateUsersWithListInput_Response)(response);
  }
  /**
  ### Creates list of users with given input array.
  Creates list of users with given input array.
  **/
  createUsersWithListInputMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof CreateUsersWithListInput_Parameters>) => this.createUsersWithListInput(parameters)
    });
  }
  /**
  ### Logs user into the system.
  Log into the system.
  **/
  async loginUser(parameters: Schema.Schema.Type<typeof LoginUser_Parameters>) {
    const params = await Schema.encodePromise(LoginUser_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(LoginUser_Response)(response);
  }
  /**
  ### Logs user into the system.
  Log into the system.
  **/
  loginUserQuery(parameters: Schema.Schema.Type<typeof LoginUser_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["LoginUser", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.loginUser(parameters)
    });
  }
  /**
  ### Logs out current logged in user session.
  Log user out of the system.
  **/
  async logoutUser(parameters: Schema.Schema.Type<typeof LogoutUser_Parameters>) {
    const params = await Schema.encodePromise(LogoutUser_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(LogoutUser_Response)(response);
  }
  /**
  ### Logs out current logged in user session.
  Log user out of the system.
  **/
  logoutUserQuery(parameters: Schema.Schema.Type<typeof LogoutUser_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["LogoutUser", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.logoutUser(parameters)
    });
  }
  /**
  ### Get user by user name.
  Get user detail based on username.
  **/
  async getUserByName(parameters: Schema.Schema.Type<typeof GetUserByName_Parameters>) {
    const params = await Schema.encodePromise(GetUserByName_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "get",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(GetUserByName_Response)(response);
  }
  /**
  ### Get user by user name.
  Get user detail based on username.
  **/
  getUserByNameQuery(parameters: Schema.Schema.Type<typeof GetUserByName_Parameters> | SkipToken) {
    return queryOptions({
      queryKey: ["GetUserByName", parameters] as QueryKey,
      queryFn: parameters === skipToken ? skipToken : async () => this.getUserByName(parameters)
    });
  }
  /**
  ### Update user resource.
  This can only be done by the logged in user.
  **/
  async updateUser(parameters: Schema.Schema.Type<typeof UpdateUser_Parameters>) {
    const params = await Schema.encodePromise(UpdateUser_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "put",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(UpdateUser_Response)(response);
  }
  /**
  ### Update user resource.
  This can only be done by the logged in user.
  **/
  updateUserMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof UpdateUser_Parameters>) => this.updateUser(parameters)
    });
  }
  /**
  ### Delete user resource.
  This can only be done by the logged in user.
  **/
  async deleteUser(parameters: Schema.Schema.Type<typeof DeleteUser_Parameters>) {
    const params = await Schema.encodePromise(DeleteUser_Parameters)(parameters);
    const response = await this.#fetch(params.path, {
      method: "delete",
      headers: params.headers,
      body: params.body
    });
    return await Schema.decodePromise(DeleteUser_Response)(response);
  }
  /**
  ### Delete user resource.
  This can only be done by the logged in user.
  **/
  deleteUserMutation() {
    return mutationOptions({
      mutationFn: async (parameters: Schema.Schema.Type<typeof DeleteUser_Parameters>) => this.deleteUser(parameters)
    });
  }
}
export const Category = Schema.Struct({
  id: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  name: Schema.String.pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type Category = Schema.Schema.Type<typeof Category>;
export const Tag = Schema.Struct({
  id: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  name: Schema.String.pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type Tag = Schema.Schema.Type<typeof Tag>;
export const Pet = Schema.Struct({
  id: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  name: Schema.String.pipe(Schema.mutable),
  category: Category.pipe(Schema.optional),
  photoUrls: Schema.Array(Schema.String.pipe(Schema.mutable)).pipe(Schema.mutable).pipe(Schema.mutable),
  tags: Schema.Array(Tag).pipe(Schema.mutable).pipe(Schema.mutable).pipe(Schema.optional),
  /** pet status in the store*/status: Schema.Literal("available", "pending", "sold").pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type Pet = Schema.Schema.Type<typeof Pet>;
export const ParametersSchema = Schema.Struct({
  path: Schema.String,
  headers: Schema.instanceOf(Headers).pipe(Schema.optional),
  body: Schema.Union(Schema.String, Schema.instanceOf(Blob), Schema.instanceOf(FormData), Schema.instanceOf(URLSearchParams)).pipe(Schema.optional)
});
export const AddPet_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  data: Schema.transform(Schema.String, Pet, {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const AddPet_Response = Schema.transformOrFail(Schema.instanceOf(Response), Pet, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const UpdatePet_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  data: Schema.transform(Schema.String, Pet, {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const UpdatePet_Response = Schema.transformOrFail(Schema.instanceOf(Response), Pet, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const FindPetsByStatus_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** Status values that need to be considered for filter*/status: Schema.Literal("available", "pending", "sold").pipe(Schema.mutable).pipe(Schema.optional)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/findByStatus?${new URLSearchParams([["status", String(from.status)]])}`
  })
});
export const FindPetsByStatus_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.Array(Pet).pipe(Schema.mutable).pipe(Schema.mutable), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const FindPetsByTags_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** Tags to filter by*/tags: Schema.Array(Schema.String.pipe(Schema.mutable)).pipe(Schema.mutable).pipe(Schema.mutable).pipe(Schema.optional)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/findByTags?${new URLSearchParams([...(from.tags?.map<[string, string]>(value => ["tags", String(value)]) ?? [])])}`
  })
});
export const FindPetsByTags_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.Array(Pet).pipe(Schema.mutable).pipe(Schema.mutable), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const GetPetById_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** ID of pet to return*/petId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/${from.petId}`
  })
});
export const GetPetById_Response = Schema.transformOrFail(Schema.instanceOf(Response), Pet, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const UpdatePetWithForm_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** ID of pet that needs to be updated*/petId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable),
  /** Name of pet that needs to be updated*/name: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  /** Status of pet that needs to be updated*/status: Schema.String.pipe(Schema.mutable).pipe(Schema.optional)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/${from.petId}?${new URLSearchParams([["name", String(from.name)], ["status", String(from.status)]])}`
  })
});
export const UpdatePetWithForm_Response = Schema.transformOrFail(Schema.instanceOf(Response), Pet, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const DeletePet_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  api_key: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  /** Pet id to delete*/petId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/${from.petId}`,
    headers: new Headers([["api_key", String(from.api_key)]])
  })
});
export const DeletePet_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.instanceOf(Blob), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.blob()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const UploadFile_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** ID of pet to update*/petId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable),
  /** Additional Metadata*/additionalMetadata: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  data: Schema.instanceOf(Blob)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/pet/${from.petId}/uploadImage?${new URLSearchParams([["additionalMetadata", String(from.additionalMetadata)]])}`,
    headers: new Headers([["Content-Type", "application/octet-stream"]]),
    body: from.data
  })
});
export const ApiResponse = Schema.Struct({
  code: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  type: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  message: Schema.String.pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type ApiResponse = Schema.Schema.Type<typeof ApiResponse>;
export const UploadFile_Response = Schema.transformOrFail(Schema.instanceOf(Response), ApiResponse, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const GetInventory_Parameters = Schema.transform(ParametersSchema, Schema.Struct({}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/store/inventory`
  })
});
export const GetInventory_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.Struct({}).pipe(Schema.mutable), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const Order = Schema.Struct({
  id: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  petId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  quantity: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  shipDate: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  /** Order Status*/status: Schema.Literal("placed", "approved", "delivered").pipe(Schema.mutable).pipe(Schema.optional),
  complete: Schema.Boolean.pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type Order = Schema.Schema.Type<typeof Order>;
export const PlaceOrder_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  data: Schema.transform(Schema.String, Order, {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/store/order`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const PlaceOrder_Response = Schema.transformOrFail(Schema.instanceOf(Response), Order, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const GetOrderById_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** ID of order that needs to be fetched*/orderId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/store/order/${from.orderId}`
  })
});
export const GetOrderById_Response = Schema.transformOrFail(Schema.instanceOf(Response), Order, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const DeleteOrder_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** ID of the order that needs to be deleted*/orderId: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/store/order/${from.orderId}`
  })
});
export const DeleteOrder_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.instanceOf(Blob), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.blob()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const User = Schema.Struct({
  id: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional),
  username: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  firstName: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  lastName: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  email: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  password: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  phone: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  /** User Status*/userStatus: Schema.Number.pipe(Schema.int()).pipe(Schema.mutable).pipe(Schema.optional)
}).pipe(Schema.mutable);
export type User = Schema.Schema.Type<typeof User>;
export const CreateUser_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  data: Schema.transform(Schema.String, User, {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const CreateUser_Response = Schema.transformOrFail(Schema.instanceOf(Response), User, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const CreateUsersWithListInput_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  data: Schema.transform(Schema.String, Schema.Array(User).pipe(Schema.mutable).pipe(Schema.mutable), {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/createWithList`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const CreateUsersWithListInput_Response = Schema.transformOrFail(Schema.instanceOf(Response), User, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const LoginUser_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** The user name for login*/username: Schema.String.pipe(Schema.mutable).pipe(Schema.optional),
  /** The password for login in clear text*/password: Schema.String.pipe(Schema.mutable).pipe(Schema.optional)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/login?${new URLSearchParams([["username", String(from.username)], ["password", String(from.password)]])}`
  })
});
export const LoginUser_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.String.pipe(Schema.mutable), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const LogoutUser_Parameters = Schema.transform(ParametersSchema, Schema.Struct({}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/logout`
  })
});
export const LogoutUser_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.instanceOf(Blob), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.blob()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const GetUserByName_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** The name that needs to be fetched. Use user1 for testing*/username: Schema.String.pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/${from.username}`
  })
});
export const GetUserByName_Response = Schema.transformOrFail(Schema.instanceOf(Response), User, {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.json()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const UpdateUser_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** name that need to be deleted*/username: Schema.String.pipe(Schema.mutable),
  data: Schema.transform(Schema.String, User, {
    strict: true,
    decode: (from, ctx) => {
      throw new Error("Not implemented");
    },
    encode: (from, ctx) => JSON.stringify(from)
  })
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/${from.username}`,
    headers: new Headers([["Content-Type", "application/json"]]),
    body: from.data
  })
});
export const UpdateUser_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.instanceOf(Blob), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.blob()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});
export const DeleteUser_Parameters = Schema.transform(ParametersSchema, Schema.Struct({
  /** The name that needs to be deleted*/username: Schema.String.pipe(Schema.mutable)
}), {
  strict: true,
  decode: (from, ctx) => {
    throw new Error("Not implemented");
  },
  encode: (from, ctx) => ({
    path: `/user/${from.username}`
  })
});
export const DeleteUser_Response = Schema.transformOrFail(Schema.instanceOf(Response), Schema.instanceOf(Blob), {
  strict: true,
  decode: (from, ctx) => Effect.promise(async () => {
    try {
      return (await from.blob()) as any;
    } catch (error: unknown) {
      throw error;
    }
  }),
  encode: (from, ctx) => Effect.promise(async () => {
    throw new Error("Not implemented");
  })
});