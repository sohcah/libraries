import * as t from "@babel/types";
import { Effect } from "effect";
import type { APIDocument } from "./types.js";
import { DocumentContext, type DocumentContextData } from "./context.js";
import { NotImplementedError } from "./errors.js";
import type { OpenApiGenerator } from "./generators/types.js";
import * as generationHelpers from "./generators/helpers.js";
import packageJson from "../package.json" with { type: "json" };

export type GeneratorOptions = {
  generators: OpenApiGenerator[];
};

const build = Effect.fn(function* (options: GeneratorOptions) {
  const ctx = yield* DocumentContext;

  for (const generator of options.generators) {
    if (!generator.initialize) continue;
    yield* generator.initialize();
  }

  for (const [pathKey, path] of Object.entries(ctx.document.paths ?? {})) {
    if (!path) continue;
    if (path.$ref) {
      return yield* new NotImplementedError({
        message: "$ref in path",
      });
    }
    for (const methodKey of ["get", "post", "put", "delete"] as const) {
      const method = path[methodKey];
      if (!method) continue;

      const operationKey = yield* generationHelpers.getKey(
        method.operationId ??
          `${methodKey}${pathKey.replace(/\/(.?)/g, (_, g) => g.toUpperCase())}`
      );

      for (const generator of options.generators) {
        if (!generator.processOperation) continue;
        yield* generator.processOperation(
          operationKey,
          pathKey,
          methodKey,
          method
        );
      }
    }
  }

  for (const schema of Object.values(ctx.document.components?.schemas ?? {})) {
    for (const generator of options.generators) {
      if (!generator.processSchema) continue;
      yield* generator.processSchema(schema);
    }
  }

  const program = t.program([
    ...ctx.imports,
    ...[...ctx.schemas.values()].flat(),
  ]);
  t.addComment(program, "leading", "eslint-disable", false);
  t.addComment(program, "leading", "prettier-ignore", false);
  t.addComment(program, "leading", ` Version: ${packageJson.version}`, true);
  t.addComment(
    program,
    "leading",
    ` Generated by @sohcah/openapi-generator`,
    true
  );
  return program;
});

export const generate = Effect.fn(function* (
  document: APIDocument<object>,
  options: GeneratorOptions
) {
  const context: DocumentContextData = {
    document,
    imports: [],
    schemas: new Map(),
    processingSchemas: new Set(),
    processingSchemaTypes: new Set(),
  };

  return yield* build(options).pipe(
    Effect.provideService(DocumentContext, context)
  );
});
